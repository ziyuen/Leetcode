```
class Solution {
public:
    // 方法：把链表拆分成前半链表和后半链表
    // 节点数目为奇数：1->2->3->4->3->2->1 拆分成 1<-2<-3和3->2->1
    // 节点数目为偶数：1->2->3->4->4->3->2->1 拆分成 1<-2<-3-<4和4->3->2->1
    bool isPalindrome(ListNode* head) {
        if (!head || !head->next) return true;
        ListNode* slow = head;
        ListNode* fast = head;
        // 辅助反转链表
        ListNode* temp = nullptr;
        // 反转链表的头指针
        ListNode* reverse_head = nullptr;
        
        //节点数目为偶数：fast为空退出循环（此时slow指向n/2+1处的节点），节点数目为奇数：fast为最后一个节点退出循环（slow指向中间节点）
        while (fast && fast->next) {
            // 即将要反转的节点
            temp = slow;
            // 慢指针走一步，快指针走两步,这是这个两倍关系，退出循环后才能成功拆分成两个链表
            slow = slow->next;
            fast = fast->next->next;
            
            // 头插法构造反转链表
            temp->next = reverse_head;
            reverse_head = temp;
        }
        // 节点数目为偶数时，上面退出循环后slow指向正中间节点，需要前进一步
        if (fast) slow = slow->next;
        
        //开始遍历前半链表和后半链表，此时reverse_head指向前半链表第一个节点，slow指向后半链表第一个节点
        while (reverse_head && slow) {
            if (reverse_head->val != slow->val) return false;
            slow = slow->next;
            reverse_head = reverse_head->next;
        }
        
        return true;
    }
};  
```

注意难点在于反转链表，以及奇数和偶数的处理